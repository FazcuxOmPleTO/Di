local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local VirtualUser = game:GetService("VirtualUser")

-- Novas posições na tela para simular o click
local FirePositions = {
    Vector2.new(-0.707, -478),
    Vector2.new(-0.654, -184)
}
local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
local centerTolerance = 30
local maxDistance = 300 -- studs
local aimPartName = "Cabesa" -- nome da cabeça do seu jogo

-- Função para checar se é possível “ver” o inimigo (raycast)
local function canSeeTarget(targetPart)
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character} -- Ignorar jogador local
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)
    if raycastResult then
        if raycastResult.Instance:IsDescendantOf(targetPart.Parent) then
            return true
        else
            return false
        end
    else
        return true
    end
end

-- Verifica se a parte inimiga está no centro da tela
local function IsAtScreenCenter(screenPos)
    return (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude <= centerTolerance
end

RunService.RenderStepped:Connect(function()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local targetPart = player.Character:FindFirstChild(aimPartName)
            if targetPart and not player.Character:FindFirstChild("FakeVisualCabesa") then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                    if distance <= maxDistance then
                        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                        if onScreen and IsAtScreenCenter(screenPos) then
                            if canSeeTarget(targetPart) then
                                -- Atira nas novas posições definidas sem parar o movimento
                                for _, pos in ipairs(FirePositions) do
                                    VirtualUser:CaptureController()
                                    VirtualUser:ClickButton1(Vector2.new(pos.X, pos.Y))
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end)







local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Configurações
local aimPartName = "Cabesa"
local fovRadius = 800 -- pixels
local smoothness = 0.5 -- Suavidade (0.5 é o que você achou melhor)
local maxTurnSpeed = 100 -- Velocidade máxima de rotação (em graus por segundo)

local function canSeeTarget(targetPart)
    local origin = Workspace.CurrentCamera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character} -- Ignorar local player
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)
    if raycastResult then
        if raycastResult.Instance:IsDescendantOf(targetPart.Parent) then
            return true -- Chegou na parte do inimigo
        else
            return false
        end
    else
        return true
    end
end

local function getClosestTarget()
    local closestPart, closestDistance = nil, math.huge
    local camera = Workspace.CurrentCamera
    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(aimPartName) then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then -- checar se vivo
                local part = player.Character[aimPartName]
                local pos, onScreen = camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(pos.X, pos.Y) - screenCenter).Magnitude
                    if dist <= fovRadius then
                        if canSeeTarget(part) then
                            if dist < closestDistance then
                                closestDistance = dist
                                closestPart = part
                            end
                        end
                    end
                end
            end
        end
    end
    return closestPart
end

RunService.RenderStepped:Connect(function(deltaTime)
    local targetPart = getClosestTarget()
    if targetPart then
        local camera = Workspace.CurrentCamera
        local currentCFrame = camera.CFrame
        local targetCFrame = CFrame.new(currentCFrame.Position, targetPart.Position)

        -- Calcular a diferença angular
        local currentDir = currentCFrame.LookVector
        local targetDir = (targetPart.Position - currentCFrame.Position).Unit
        local angle = math.acos(math.clamp(currentDir:Dot(targetDir), -1, 1))

        -- Limitar a velocidade de rotação
        local maxAngleThisFrame = math.rad(maxTurnSpeed) * deltaTime
        local t = math.min(smoothness, maxAngleThisFrame / math.max(angle, 0.0001))

        -- Interpolação suave
        camera.CFrame = currentCFrame:Lerp(targetCFrame, t)
    end
end)
