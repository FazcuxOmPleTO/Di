-- Auto-fire com verificação de objetos compatível com seu applyCabesa
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local VirtualUser = game:GetService("VirtualUser")

-- Configurações
local FirePositions = {
    Vector2.new(-0.707, -832),
    Vector2.new(-0.654, -246)
}
local centerTolerance = 30
local maxDistance = 300 -- studs
local aimPartName = "Cabesa" -- seu nome de cabeça

-- Função de raycast (verifica se há objeto bloqueando)
local function canSeeTarget(targetPart)
    if not targetPart or not targetPart.Parent then return false end
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = { LocalPlayer.Character } -- ignorar self
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local result = Workspace:Raycast(origin, direction, raycastParams)
    if result then
        return result.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true
end

local function IsAtScreenCenter(screenPos)
    local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    return (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude <= centerTolerance
end

RunService.RenderStepped:Connect(function()
    -- Segurança: só continua se o LocalPlayer tiver character e HRP
    if not LocalPlayer or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            -- Prioriza a Cabesa "real". não use FakeVisualCabesa como alvo.
            local targetPart = player.Character:FindFirstChild(aimPartName)
                or player.Character:FindFirstChild("cabesa") -- fallback se houver lowercase

            -- Se por acaso o alvo for a FakeVisual, tente achar a real (defensivo)
            if targetPart and targetPart.Name == "FakeVisualCabesa" then
                targetPart = nil
            end

            if targetPart then
                -- checa vida e existência do humanoide
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    -- distancia
                    local ok, hrpPos = pcall(function() return LocalPlayer.Character.HumanoidRootPart.Position end)
                    if not ok or not hrpPos then break end

                    local distance = (hrpPos - targetPart.Position).Magnitude
                    if distance <= maxDistance then
                        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                        if onScreen and IsAtScreenCenter(screenPos) then
                            if canSeeTarget(targetPart) then
                                -- atira nas posições fornecidas sem parar o movimento
                                for _, pos in ipairs(FirePositions) do
                                    VirtualUser:CaptureController()
                                    VirtualUser:ClickButton1(Vector2.new(pos.X, pos.Y))
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end)

-- Primeiro script: Bypass do anticheat
task.wait(2) -- espera o anticheat carregar primeiro

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- pega o remote ExploitBan
local ExploitBan = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("ExploitBan")

-- função "fake" para neutralizar chamadas indesejadas
local function blockEvent()
    return function(...)
        --print("Bloqueado:", ...)
    end
end

-- ⚡ Neutraliza conexões que o anticheat cria
for _, conn in pairs(getconnections(script:GetPropertyChangedSignal("Disabled"))) do
    conn:Disable()
end
for _, conn in pairs(getconnections(script:GetPropertyChangedSignal("Parent"))) do
    conn:Disable()
end
for _, conn in pairs(getconnections(script.AncestryChanged)) do
    conn:Disable()
end

-- ⚡ Neutraliza monitoramento de hitbox (Size / Mesh / Scale)
local function safePart(part)
    for _, conn in pairs(getconnections(part:GetPropertyChangedSignal("Size"))) do
        conn:Disable()
    end
    local mesh = part:FindFirstChildOfClass("SpecialMesh")
    if mesh then
        for _, conn in pairs(getconnections(mesh:GetPropertyChangedSignal("Scale"))) do
            conn:Disable()
        end
    end
end

local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
for _, v in pairs(char:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("MeshPart") then
        safePart(v)
    end
end

-- ⚡ Neutraliza monitoramento de CanCollide (noclip)
local function disableCanCollideChecks(model)
    for _, v in pairs(model:GetDescendants()) do
        if v:IsA("BasePart") then
            for _, conn in pairs(getconnections(v:GetPropertyChangedSignal("CanCollide"))) do
                conn:Disable()
            end
        end
    end
end
disableCanCollideChecks(char)

LocalPlayer.CharacterAdded:Connect(function(newChar)
    task.wait(3)
    disableCanCollideChecks(newChar)
end)

print("[Bypass] Anticheat custom desativado (exceto Walk/Jump/Fly)")

-- Segundo script: Aimbot
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

-- Configurações
local aimPartName = "Cabesa"
local fovRadius = 30 -- pixels
local smoothness = 1 -- Suavidade
local maxTurnSpeed = 3990 -- Velocidade máxima de rotação
local aimEnabled = true -- Controle para ativar/desativar aimbot

local function canSeeTarget(targetPart)
    local origin = Workspace.CurrentCamera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit * 1000
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)  
    if raycastResult then  
        return raycastResult.Instance:IsDescendantOf(targetPart.Parent)  
    end  
    return true
end

local function getClosestTarget()
    local closestPart, closestDistance = nil, math.huge
    local camera = Workspace.CurrentCamera
    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

    for _, player in pairs(Players:GetPlayers()) do  
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(aimPartName) then  
            local humanoid = player.Character:FindFirstChild("Humanoid")  
            if humanoid and humanoid.Health > 0 then  
                local part = player.Character[aimPartName]  
                local pos, onScreen = camera:WorldToViewportPoint(part.Position)  
                if onScreen then  
                    local dist = (Vector2.new(pos.X, pos.Y) - screenCenter).Magnitude  
                    if dist <= fovRadius and canSeeTarget(part) then  
                        if dist < closestDistance then  
                            closestDistance = dist  
                            closestPart = part  
                        end  
                    end
                end  
            end  
        end  
    end  
    return closestPart
end

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        aimEnabled = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        aimEnabled = false
    end
end)

local lastTargetPos = nil
RunService.RenderStepped:Connect(function(deltaTime)
    if not aimEnabled then return end

    local targetPart = getClosestTarget()  
    local camera = Workspace.CurrentCamera  

    if targetPart then  
        local offset = Vector3.new(math.random(-0.2, 0.2), math.random(-0.2, 0.2), math.random(-0.2, 0.2))  
        local targetPos = targetPart.Position + offset  

        if lastTargetPos then  
            targetPos = lastTargetPos:Lerp(targetPart.Position, 0.3)
        end  
        lastTargetPos = targetPos  

        local currentCFrame = camera.CFrame  
        local targetCFrame = CFrame.new(currentCFrame.Position, targetPos)  

        local currentDir = currentCFrame.LookVector  
        local targetDir = (targetPos - currentCFrame.Position).Unit  
        local angle = math.acos(math.clamp(currentDir:Dot(targetDir), -1, 1))  

        local maxAngleThisFrame = math.rad(maxTurnSpeed) * deltaTime  
        local t = math.min(smoothness, maxAngleThisFrame / math.max(angle, 0.0001))  

        camera.CFrame = currentCFrame:Lerp(targetCFrame, t)  
    else  
        lastTargetPos = nil
    end
end)

-- Espera 6 segundos antes de executar o terceiro script
task.wait(6)

-- Terceiro script: Efeito de cabeça grande
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local currentSize = Vector3.new(2, 2, 2) -- tamanho final da Cabesa

local function applyCabesa(char)
    task.wait(0.1)
    local cabesa = char:FindFirstChild("Cabesa")
    if not cabesa or char == LocalPlayer.Character then return end
    if char:FindFirstChild("FakeVisualCabesa") then return end

    local fake = cabesa:Clone()
    fake.Name = "FakeVisualCabesa"
    fake.Size = Vector3.new(1, 1, 1)
    fake.Transparency = 0
    fake.CanCollide = false
    fake.Anchored = false
    fake.Massless = true
    fake.Parent = char

    cabesa.Size = currentSize
    cabesa.Transparency = 1
    cabesa.CanCollide = false
    cabesa.Massless = true

    local face = cabesa:FindFirstChildOfClass("Decal")
    if face then
        face.Transparency = 1
    end

    local weld = Instance.new("WeldConstraint")
    weld.Part0 = cabesa
    weld.Part1 = fake
    weld.Parent = cabesa

    cabesa:GetPropertyChangedSignal("Size"):Connect(function()
        if cabesa.Size ~= currentSize then
            cabesa.Size = currentSize
        end
    end)
end

for _, player in pairs(Players:GetPlayers()) do
    local char = workspace:FindFirstChild(player.Name)
    if char then
        applyCabesa(char)
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        applyCabesa(char)
    end)
end)

for _, player in pairs(Players:GetPlayers()) do
    player.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        applyCabesa(char)
    end)
end





loadstring(game:HttpGet("https://raw.githubusercontent.com/Waza80/scripts-new/refs/heads/main/AXRemove.lua"))()


loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
