-- AUTO-FIRE COMPATÍVEL COM CABESA 2.2
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local VirtualUser = game:GetService("VirtualUser")

-- CONFIGURAÇÕES
local FirePositions = {
    Vector2.new(-0.707, -832),
    Vector2.new(-0.654, -246)
}
local centerTolerance = 20
local maxDistance = 300 -- studs

-- Função para detectar partes com face (mesma do CABESA)
local function hasFaceMarker(obj)
    if not obj then return false end
    if obj:FindFirstChild("face") then return true end
    for _,c in ipairs(obj:GetChildren()) do
        if c:IsA("Decal") or c:IsA("Texture") then
            return true
        end
    end
    return false
end

-- Função de raycast para linha de visão
local function canSeeTarget(targetPart)
    if not targetPart or not targetPart.Parent then return false end
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = { LocalPlayer.Character }
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local result = Workspace:Raycast(origin, direction, raycastParams)
    if result then
        return result.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true
end

-- Checa se o alvo está no centro da tela
local function IsAtScreenCenter(screenPos)
    local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    return (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude <= centerTolerance
end

-- Scaner principal baseado no CABESA 2.2
RunService.RenderStepped:Connect(function()
    if not LocalPlayer or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local hrpPos = LocalPlayer.Character.HumanoidRootPart.Position

    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and hasFaceMarker(obj) then
            -- sobe até encontrar o Model com Humanoid
            local model = obj
            while model and not model:IsA("Model") do
                model = model.Parent
            end

            if model and model:FindFirstChildOfClass("Humanoid") then
                local player = Players:GetPlayerFromCharacter(model)
                if player and player ~= LocalPlayer then
                    -- evita FakeVisualCabesa
                    if obj.Name == "FakeVisualCabesa" then
                        continue
                    end

                    local humanoid = model:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local distance = (hrpPos - obj.Position).Magnitude
                        if distance <= maxDistance then
                            local screenPos, onScreen = Camera:WorldToViewportPoint(obj.Position)
                            if onScreen and IsAtScreenCenter(screenPos) and canSeeTarget(obj) then
                                -- atira nas posições fornecidas
                                for _, pos in ipairs(FirePositions) do
                                    VirtualUser:CaptureController()
                                    VirtualUser:ClickButton1(Vector2.new(pos.X, pos.Y))
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end)



-- 1

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- pega o remote ExploitBan
local ExploitBan = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("ExploitBan")

-- função "fake" para neutralizar chamadas indesejadas
local function blockEvent()
    return function(...)
        --print("Bloqueado:", ...)
    end
end

-- ⚡ Neutraliza conexões que o anticheat cria
for _, conn in pairs(getconnections(script:GetPropertyChangedSignal("Disabled"))) do
    conn:Disable()
end
for _, conn in pairs(getconnections(script:GetPropertyChangedSignal("Parent"))) do
    conn:Disable()
end
for _, conn in pairs(getconnections(script.AncestryChanged)) do
    conn:Disable()
end

-- ⚡ Neutraliza monitoramento de hitbox (Size no HRP)
local function safeHRP(part)
    for _, conn in pairs(getconnections(part:GetPropertyChangedSignal("Size"))) do
        conn:Disable()
    end
end

-- ⚡ Neutraliza monitoramento de CanCollide (noclip no HRP)
local function disableCanCollideChecks(hrp)
    for _, conn in pairs(getconnections(hrp:GetPropertyChangedSignal("CanCollide"))) do
        conn:Disable()
    end
end

-- ⚡ Neutraliza monitoramento de ChildAdded no HRP (fly/noclip/btools)
local function disableChildAddedChecks(hrp)
    for _, conn in pairs(getconnections(hrp.ChildAdded)) do
        conn:Disable()
    end
end

-- ⚡ Neutraliza monitoramento de PlatformStand no Humanoid (para fly)
local function disableHumanoidChecks(humanoid)
    for _, prop in ipairs({"PlatformStand"}) do
        for _, conn in pairs(getconnections(humanoid:GetPropertyChangedSignal(prop))) do
            conn:Disable()
        end
    end
end

-- ⚡ Neutraliza monitoramento no Animate (Disabled/Parent/Ancestry)
local function disableAnimateChecks(animate)
    for _, conn in pairs(getconnections(animate:GetPropertyChangedSignal("Disabled"))) do
        conn:Disable()
    end
    for _, conn in pairs(getconnections(animate:GetPropertyChangedSignal("Parent"))) do
        conn:Disable()
    end
    for _, conn in pairs(getconnections(animate.AncestryChanged)) do
        conn:Disable()
    end
end

-- Aplica no personagem local
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local humanoid = char:WaitForChild("Humanoid")
local animate = char:FindFirstChild("Animate")

safeHRP(hrp)
disableCanCollideChecks(hrp)
disableChildAddedChecks(hrp)
disableHumanoidChecks(humanoid)
if animate then
    disableAnimateChecks(animate)
end

-- Aplica em personagens de outros jogadores (para hitbox)
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer and player.Character then
        local otherHrp = player.Character:FindFirstChild("HumanoidRootPart")
        if otherHrp then
            safeHRP(otherHrp)
        end
    end
end

-- Monitora novos personagens locais
LocalPlayer.CharacterAdded:Connect(function(newChar)
    task.wait(3)
    local newHrp = newChar:WaitForChild("HumanoidRootPart")
    local newHumanoid = newChar:WaitForChild("Humanoid")
    local newAnimate = newChar:FindFirstChild("Animate")
    
    safeHRP(newHrp)
    disableCanCollideChecks(newHrp)
    disableChildAddedChecks(newHrp)
    disableHumanoidChecks(newHumanoid)
    if newAnimate then
        disableAnimateChecks(newAnimate)
    end
end)

-- Monitora novos jogadores e seus personagens (para hitbox)
Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(newChar)
            task.wait(3)
            local newHrp = newChar:FindFirstChild("HumanoidRootPart")
            if newHrp then
                safeHRP(newHrp)
            end
        end)
    end
end)

print("[Bypass] Anticheat custom desativado (exceto Walk/Jump)")





-- 2

-- SCRIPT CABESA 2.2 LIMPO
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local workspace = workspace

local currentSize = Vector3.new(3.2,3.2,3.2)
local SCAN_DELAY = 2.2 -- segundos entre varreduras completas do workspace

local function hasFaceMarker(obj)
    if not obj then return false end
    if obj:FindFirstChild("face") then return true end
    for _,c in ipairs(obj:GetChildren()) do
        if c:IsA("Decal") or c:IsA("Texture") then
            return true
        end
    end
    return false
end

local function applyToPart(part, model)
    if not part or not model then return end
    if model == LocalPlayer.Character then return end
    if model:FindFirstChild("FakeVisualCabesa") then return end

    pcall(function()
        local fake = part:Clone()
        fake.Name = "FakeVisualCabesa"
        fake.Size = Vector3.new(1,1,1)
        fake.Transparency = 0
        fake.CanCollide = false
        fake.Anchored = false
        fake.Massless = true
        fake.Parent = model

        if fake:IsA("BasePart") then
            pcall(function() fake.CFrame = part.CFrame end)
        end

        if part:IsA("BasePart") then
            pcall(function() part.Size = currentSize end)
            pcall(function() part.Transparency = 1 end)
            pcall(function() part.CanCollide = false end)
            pcall(function() part.Massless = true end)
        end

        local f = part:FindFirstChild("face")
        if f and f:IsA("Decal") then pcall(function() f.Transparency = 1 end) end
        for _,c in ipairs(part:GetChildren()) do
            if c:IsA("Decal") or c:IsA("Texture") then
                pcall(function() c.Transparency = 1 end)
            end
        end

        if fake:IsA("BasePart") and part:IsA("BasePart") then
            pcall(function()
                local weld = Instance.new("WeldConstraint")
                weld.Part0 = fake
                weld.Part1 = part
                weld.Parent = fake
            end)
        end

        if part:IsA("BasePart") then
            part:GetPropertyChangedSignal("Size"):Connect(function()
                if part and part.Size ~= currentSize then
                    pcall(function() part.Size = currentSize end)
                end
            end)
        end
    end)
end

spawn(function()
    while true do
        for _,obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and hasFaceMarker(obj) then
                local model = obj
                while model and not model:IsA("Model") do
                    model = model.Parent
                end
                if model and model:IsA("Model") and model:FindFirstChildOfClass("Humanoid") then
                    applyToPart(obj, model)
                end
            end
        end
        task.wait(SCAN_DELAY)
    end
end)
